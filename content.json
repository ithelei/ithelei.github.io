{"meta":{"title":"养码哥","subtitle":null,"description":null,"author":"He Lei","url":"http://www.ithelei.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-26T13:42:29.302Z","updated":"2019-08-26T05:57:26.706Z","comments":false,"path":"/404.html","permalink":"http://www.ithelei.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-26T15:43:12.807Z","updated":"2019-08-26T15:43:12.807Z","comments":false,"path":"about/index.html","permalink":"http://www.ithelei.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-08-26T13:42:29.308Z","updated":"2019-08-26T05:57:26.713Z","comments":false,"path":"books/index.html","permalink":"http://www.ithelei.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-26T13:42:29.311Z","updated":"2019-08-26T05:57:26.715Z","comments":false,"path":"categories/index.html","permalink":"http://www.ithelei.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-26T14:06:33.045Z","updated":"2019-08-26T05:57:26.717Z","comments":true,"path":"links/index.html","permalink":"http://www.ithelei.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-26T13:42:29.318Z","updated":"2019-08-26T05:57:26.720Z","comments":false,"path":"repository/index.html","permalink":"http://www.ithelei.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-26T13:42:29.321Z","updated":"2019-08-26T05:57:26.722Z","comments":false,"path":"tags/index.html","permalink":"http://www.ithelei.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"能力图谱","slug":"能力图谱","date":"2019-09-01T01:20:45.000Z","updated":"2019-09-01T01:24:41.711Z","comments":true,"path":"2019/09/01/能力图谱/","link":"","permalink":"http://www.ithelei.com/2019/09/01/能力图谱/","excerpt":"","text":"工程师能力图谱： 技术经理能力图谱 技术总监能力图谱 CTO能力图谱","categories":[{"name":"能力图谱","slug":"能力图谱","permalink":"http://www.ithelei.com/categories/能力图谱/"}],"tags":[{"name":"能力图谱","slug":"能力图谱","permalink":"http://www.ithelei.com/tags/能力图谱/"}]},{"title":"ECS上搭建Docker（CentOS7）","slug":"ECS上搭建Docker（CentOS7）","date":"2019-08-31T13:27:24.000Z","updated":"2019-08-31T15:02:39.023Z","comments":true,"path":"2019/08/31/ECS上搭建Docker（CentOS7）/","link":"","permalink":"http://www.ithelei.com/2019/08/31/ECS上搭建Docker（CentOS7）/","excerpt":"","text":"本文介绍在CentOS系统上部署Docker的过程。 背景信息本教程适用于熟悉Linux操作系统。 本教程示例步骤中使用的操作系统版本为CentOS 7.2 64 3.10.0-514.6.2.el7.x86_64 说明 Docker要求64位的系统且内核版本至少为3.10。部署Docker完成以下操作，部署Docker： 添加yum源。 yum install epel-release –y yum clean all yum list 安装并运行Docker。 yum install docker-io –y systemctl start docker 检查安装结果。 docker info 出现以下说明信息则表明安装成功。 使用DockerDocker有以下基本用法： 管理Docker守护进程。 systemctl start docker 运行Docker守护进程 systemctl stop docker 停止Docker守护进程 systemctl restart docker 重启Docker守护进程 管理镜像。本文使用的是来自阿里云仓库的Apache镜像。 docker pull registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5 修改标签。由于阿里云仓库镜像的镜像名称很长，可以修改镜像标签以便记忆区分。 docker tag registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5:latest aliweb:v1 查看已有镜像。 docker images 强制删除镜像。 docker rmi –f registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5 管理容器。 进入容器。e1xxxxxxxxxe是执行docker images命令查询到的ImageId，使用docker run命令进入容器。 docker run –ti e1xxxxxxxxxe /bin/bash 退出容器。使用exit命令退出当前容器。 run命令加上–d参数可以在后台运行容器，–name指定容器命名为apache。 docker run -d –name apache e1xxxxxxxxxe 进入后台运行的容器。 docker exec -ti apache /bin/bash 将容器做成镜像。 docker commit containerID/containerName newImageName:tag 为了方便测试和恢复，将源镜像运行起来后，再做一个命名简单的镜像做测试。 docker commit 4c8066cd8c01 apachephp:v1 运行容器并将宿主机的8080端口映射到容器里去。 docker run -d -p 8080:80 apachephp:v1 在浏览器输入宿主机IP加8080端口访问测试，出现以下内容则说明运行成功。 制作镜像完成以下操作，制作镜像： 准备Dockerfile内容。 ` # vim Dockerfile FROM apachephp:v1 #声明基础镜像来源 MAINTAINER DTSTACK #声明镜像拥有者 RUN mkdir /dtstact #RUN后面接容器运行前需要执行的命令，由于Dockerfile文件不能超过127行，因此当命令较多时建议写到脚本中执行 ENTRYPOINT ping www.aliyun.com #开机启动命令，此处最后一个命令需要是可在前台持续执行的命令，否则容器后台运行时会因为命令执行完而退出。 ` 构建镜像。 ` docker build -t webcentos:v1 . # . 是Dockerfile文件的路径，不能忽略 docker images #查看是否创建成功 docker run –d webcentos:v1 #后台运行容器 docker ps #查看当前运行中的容器 docker ps –a #查看所有容器，包括未运行中的 docker logs CONTAINER ID/IMAGE #如未查看到刚才运行的容器，则用容器id或者名字查看启动日志排错 docker commit fb2844b6c070 dtstackweb:v1 #commit 后接容器id 和构建新镜像的名称和版本号。 docker images #列出本地（已下载的和本地创建的）镜像 docker push #将镜像推送至远程仓库，默认为 Docker Hub ` 将镜像推送到registry。 其中ImageId和镜像版本号请您根据自己的镜像信息进行填写。 ` docker login --username=dtstack_plus registry.cn-shanghai.aliyuncs.com #执行后输入镜像仓库密码 docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号] docker push registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号] `在镜像仓库能查看到镜像版本信息则说明推送成功。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.ithelei.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.ithelei.com/tags/Docker/"}]},{"title":"Tomcat服务启动非常缓慢","slug":"Tomcat服务启动非常缓慢","date":"2019-08-31T11:36:42.000Z","updated":"2019-08-31T12:16:45.879Z","comments":true,"path":"2019/08/31/Tomcat服务启动非常缓慢/","link":"","permalink":"http://www.ithelei.com/2019/08/31/Tomcat服务启动非常缓慢/","excerpt":"","text":"概述：本文主要介绍Tomcat服务启动非常缓慢的解决方法。 问题症状 Tomcat启动非常缓慢，查看日志如下。 问题原因 SecureRandom这个jre的工具类的问题。 解决方案：在Tomcat环境中解决。 可以通过配置JRE使用非阻塞的Entropy Source。 在catalina.sh文件中加入如下内容 -Djava.security.egd=file:/dev/./urandom 加入后重启Tomcat，查看Tomcat服务启动日志，启动耗时下降。 在JVM环境中解决 打开 $JAVA_PATH/jre/lib/security/java.security这个文件。 在文件中找到如下内容。 securerandom.source=file:/dev/urandom 将内容替换成如下内容 securerandom.source=file:/dev/./urandom","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.ithelei.com/categories/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.ithelei.com/tags/Tomcat/"}]},{"title":"Linux性能优化实战","slug":"Linux性能优化实战","date":"2019-08-31T11:33:45.000Z","updated":"2019-08-31T13:35:58.695Z","comments":true,"path":"2019/08/31/Linux性能优化实战/","link":"","permalink":"http://www.ithelei.com/2019/08/31/Linux性能优化实战/","excerpt":"","text":"如图：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.ithelei.com/categories/Linux/"},{"name":"性能","slug":"Linux/性能","permalink":"http://www.ithelei.com/categories/Linux/性能/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.ithelei.com/tags/Linux/"},{"name":"性能","slug":"性能","permalink":"http://www.ithelei.com/tags/性能/"}]},{"title":"到底应该怎么理解（平均负载）？","slug":"到底应该怎么理解（平均负载）","date":"2019-08-30T13:27:24.000Z","updated":"2019-08-31T14:08:59.255Z","comments":true,"path":"2019/08/30/到底应该怎么理解（平均负载）/","link":"","permalink":"http://www.ithelei.com/2019/08/30/到底应该怎么理解（平均负载）/","excerpt":"","text":"每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。 ` $uptime 02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88 `但我想问的是，你真的知道这里每列输出的含义吗？ 我相信你对前面的几列比较熟悉，它们分别是当前时间、系统运行时间以及正在登录用户数。 ` 02:34:03 // 当前时间 up 2 days, 20:14 // 系统运行时间 1 user // 正在登录用户数 `而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。 平均负载？这个词对很多人来说，可能既熟悉又陌生，我们每天的工作中，也都会提到这个词，但你真正理解它背后的含义吗？ 如何观测和理解这个最常见、也是最重要的系统指标。 平均负载不就是单位时间内的 CPU 使用率吗？上面的 0.63，就代表 CPU 使用率是 63%。其实并不是这样，如果你方便的话，可以通过执行 man uptime 命令，来了解平均负载的详细解释。 简单来说，平均负载是指单位时间内，系统处于可运行状态 和不可中断状态的平均进程数，也就是平均活跃进程数 ，它和 CPU 使用率并没有直接关系。这里我先解释下，可运行状态和不可中断状态这俩词儿。 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。 比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。 所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制 因此，你可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。 既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？ 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。 平均负载为多少时合理说完了什么是平均负载，现在我们再回到最开始的例子，在 uptime 命令的结果里，那三个时间段的平均负载数，多大的时候能说明系统负载高？或是多小的时候就能说明系统负载很低呢？ 我们知道，平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时，首先你要知道系统有几个 CPU ，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取，比如： ` # 关于 grep 和 wc 的用法请查询它们的手册或者网络搜索 $ grep &apos;model name&apos; /proc/cpuinfo | wc -l 2 `有了 CPU 个数，我们就可以判断出，当平均负载比 CPU 个数还大的时候，系统已经出现了过载。 不过，且慢，新的问题又来了。我们在例子中可以看到，平均负载有三个数值，到底该参考哪一个呢？ 实际上，都要看。三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，让我们能更全面、更立体地理解目前的负载状况。 打个比方，就像初秋时北京的天气，如果只看中午的温度，你可能以为还在 7 月份的大夏天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。 同样的，前面说到的 CPU 的三个负载时间段也是这个道理。 如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。 但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。 反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。 这里我再举个例子，假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。 那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？ 在我看来，当平均负载高于 CPU 数量 70% 的时候 ，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。 但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。 平均负载与 CPU 使用率现实工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，我也做一个区分。 可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？ 我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了 而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如： 而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如： I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高； 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。 平均负载案例分析下面，我们以三个示例分别来看这三种情况，并用 iostat、mpstat、pidstat 等工具，找出平均负载升高的根源。 因为案例分析都是基于机器上的操作，所以不要只是听听、看看就够了，最好还是跟着我实际操作一下。 你的准备下面的案例都是基于 Ubuntu 18.04，当然，同样适用于其他 Linux 系统。我使用的案例环境如下所示。 机器配置：2 CPU，8GB 内存。 预先安装 stress 和 sysstat 包，如 apt install stress sysstat。 在这里，我先简单介绍一下 stress 和 sysstat。 stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。 而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。 mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。 pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。 此外，每个场景都需要你开三个终端，登录到同一台 Linux 机器中。 实验之前，你先做好上面的准备。如果包的安装有问题，可以先在 Google 一下自行解决，如果还是解决不了，再来留言区找我，这事儿应该不难。 另外要注意，下面的所有命令，我们都是默认以 root 用户运行。所以，如果你是用普通用户登陆的系统，一定要先运行 sudo su root 命令切换到 root 用户。 如果上面的要求都已经完成了，你可以先用 uptime 命令，看一下测试前的平均负载情况： `$uptame ..., load average: 0.11, 0.15, 0.09 `场景一：CPU 密集型进程首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景： ` $ stress --cpu 1 --timeout 600 `接着，在第二个终端运行 uptime 查看平均负载的变化情况： ` # -d 参数表示高亮显示变化的区域 $ watch -d uptime ..., load average: 1.00, 0.75, 0.39 `最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况： `# -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据 $ mpstat -P ALL 5 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:30:06 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 13:30:11 all 50.05 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 49.95 13:30:11 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 13:30:11 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 `从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。 那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询： ` # 间隔 5 秒后输出一组数据 $ pidstat -u 5 1 13:37:07 UID PID %usr %system %guest %wait %CPU CPU Command 13:37:12 0 2962 100.00 0.00 0.00 0.00 100.00 1 stress `从这里可以明显看到，stress 进程的 CPU 使用率为 100%。 场景二：I/O 密集型进程首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync： `$stress -i 1 --timeout 600 `还是在第二个终端运行 uptime 查看平均负载的变化情况： `$watch -d uptime ..., load average: 1.06, 0.58, 0.37 `然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况： `# 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据 $ mpstat -P ALL 5 1 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:41:28 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 13:41:33 all 0.21 0.00 12.07 32.67 0.00 0.21 0.00 0.00 0.00 54.84 13:41:33 0 0.43 0.00 23.87 67.53 0.00 0.43 0.00 0.00 0.00 7.74 13:41:33 1 0.00 0.00 0.81 0.20 0.00 0.00 0.00 0.00 0.00 98.99 `从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。 那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询： `# 间隔 5 秒后输出一组数据，-u 表示 CPU 指标 $ pidstat -u 5 1 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:42:08 UID PID %usr %system %guest %wait %CPU CPU Command 13:42:13 0 104 0.00 3.39 0.00 0.00 3.39 1 kworker/1:1H 13:42:13 0 109 0.00 0.40 0.00 0.00 0.40 0 kworker/0:1H 13:42:13 0 2997 2.00 35.53 0.00 3.99 37.52 1 stress 13:42:13 0 3057 0.00 0.40 0.00 0.00 0.40 0 pidstat `可以发现，还是 stress 进程导致的。 场景三：大量进程的场景当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。 比如，我们还是使用 stress，但这次模拟的是 8 个进程： `$stress -c 8 --timeout 600 `由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97： `$uptime ..., load average: 7.97, 5.93, 3.02 `接着再运行 pidstat 来看一下进程的情况： `# 间隔 5 秒后输出一组数据 $ pidstat -u 5 1 14:23:25 UID PID %usr %system %guest %wait %CPU CPU Command 14:23:30 0 3190 25.00 0.00 0.00 74.80 25.00 0 stress 14:23:30 0 3191 25.00 0.00 0.00 75.20 25.00 0 stress 14:23:30 0 3192 25.00 0.00 0.00 74.80 25.00 1 stress 14:23:30 0 3193 25.00 0.00 0.00 75.00 25.00 1 stress 14:23:30 0 3194 24.80 0.00 0.00 74.60 24.80 0 stress 14:23:30 0 3195 24.80 0.00 0.00 75.00 24.80 0 stress 14:23:30 0 3196 24.80 0.00 0.00 74.60 24.80 1 stress 14:23:30 0 3197 24.80 0.00 0.00 74.80 24.80 1 stress 14:23:30 0 3200 0.00 0.20 0.00 0.20 0.20 0 pidstat `可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。 小结分析完这三个案例，我再来归纳一下平均负载的理解 平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意： 平均负载高有可能是 CPU 密集型进程导致的； 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了； 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.ithelei.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.ithelei.com/tags/Linux/"}]},{"title":"MySQL优化(1)","slug":"MySQL优化(1)","date":"2019-08-28T14:39:45.000Z","updated":"2019-08-28T13:21:45.209Z","comments":true,"path":"2019/08/28/MySQL优化(1)/","link":"","permalink":"http://www.ithelei.com/2019/08/28/MySQL优化(1)/","excerpt":"","text":"MySQL查询优化应注意的问题 对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上建立索引。 应尽量避免在where子句中使用！=或 &lt;&gt; 操作符，否则引擎将放弃索引而进行全表扫描。 应尽量避免在where字句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描，如select id from t where num is null 可以在num上设置默认值为0，确保表中num列没有null值，如select id from t where num = 0。 应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。如下面的语句：select id from t where num =10 or num =20,可以改成下面的语句：select id from t where num =10 union all select id from t where num =20 下面的查询也将导致全表扫描： select id from t where name like &#39;%abc%&#39; in 和 not in也要慎用，否则会导致全表扫描。如下面的语句： select id from t where num in (1,2,3) 对于连续的数值，能用between 就不要用 in 了。 select id from t where num between 1 and 3 如果在where子句中使用参数，也会导致全表扫描。因为sql只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择选择推迟到运行时；他必须在编译时进行选择。然而。如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择输入项。如下面的语句将进行全表扫描。 select id from t where num=@num 可以改为强制查询使用索引，如下语句： select id from t with (index(索引名)) where num =@num 应尽量避免在where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描，如下面的语句： select id from t where num/2=100应改为 select id from t where num=100*2 应尽量避免在where子句中 对字段进行函数操作，这将导致殷勤放弃使用索引而进行全表扫描，如下面的语句： select id from t where SUBSTRING(name,1,3)=&#39;abc&#39; –name以abc开头的id select id from t where DATEDIFF(day,createdate,&#39;2019-08-28&#39;)=0 –2019-08-28生成的id 。 应改为如下面的语句： `select id from ｔ where nane like &apos;abc%&apos;` `select id from t where createdate &gt; = &apos;2019-08-28&apos; and createdate &lt; &apos;2019-08-29&apos;` 不要在where 子句中的 “=” 左边进行函数、算数运算或其他表达式运算。否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 很多时候用exists代替in是一个好的选择。 select num from a where num in （select num from b） 用下面的语句替换。 `select num from a where exists （select 1 from b where num=a.num）`","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/tags/MySQL/"}]},{"title":"MySQL优化(2)","slug":"MySQL优化(2)","date":"2019-08-28T13:36:45.000Z","updated":"2019-08-28T14:03:47.468Z","comments":true,"path":"2019/08/28/MySQL优化(2)/","link":"","permalink":"http://www.ithelei.com/2019/08/28/MySQL优化(2)/","excerpt":"","text":"继MySQL优化(1) 并不是所有索引对查询都有效，sql语句是根军表中数据来进行优化的，当索引列有大量数据重复时，sql查询可能不会去利用索引，如某表中有字段sex,male,female几乎各一半，那么及时在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的select的效率，但同时也降低了insert和update的效率，因为insert和update时有可能会重建索引，所以怎样建索引需要慎重考虑，是具体情况而定。一个表的索引不要超过5个。若太多则时，考虑那些不常使用列上的索引是否有必要。 应尽可能地避免更新 lustered素引数据列，因为 clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要烦繁更新 clustered索引数据列，那么需要考虑是否将该索引建为 clustered索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每个字符，而对于数字型而言只需要比较一次就够了。 尽可能地使用 VARCHAR/NVARCHAR代替 CHAR/NCHAR，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 SELECT＊ FROM t，用具体的字段列表代替“＊”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，应注意索引非常有限(只有主键索引)。 避免频繁创建和删除临时表，以减少系统表资源的消耗 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用,大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 SELECT into代替 CREATEtable，避免造成大量log，以提高速度:如果数据量不大，为了缓和系统表的资源，应先CREATE table，然后 INSERT 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式刷除，先 truncate tabl然后 DROP table，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应考虑改写 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效 与临时表一样，游标并不是不可使用。对小型数据集使用FAST_ FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的历程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON，在结束时设置SETNOCOUNT OFF。无须在执行存储过程和触发器的每个语句后向客户端发送 DONE INPROC消息。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理 尽量避免大事务操作，提高系统并发能力","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/tags/MySQL/"}]},{"title":"MySQL规范","slug":"MySQL规范","date":"2019-08-27T13:45:00.000Z","updated":"2019-08-27T14:16:51.451Z","comments":true,"path":"2019/08/27/MySQL规范/","link":"","permalink":"http://www.ithelei.com/2019/08/27/MySQL规范/","excerpt":"","text":"一、基础规范 表存储引擎必须使用InnoDB 表字符集默认使用utf8，必要时候使用utf8mb4 解读： （1）通用，无乱码风险，汉字3字节，英文1字节。 （2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它。 禁止使用存储过程，视图，触发器，Event。 解读： （1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层。 （2）调试，排错，迁移都比较困难，扩展性较差。 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径。 禁止在线上环境做数据库压力测试。 测试，开发，线上数据库环境必须隔离。 二、命名规范 库名，表名，列名必须用小写，采用下划线分隔。 解读：abc，Abc，ABC都是不允许的。 库名，表名，列名必须见名知义，长度不要超过32字符。 解读：tmp，wujun谁TM知道这些库是干嘛的。 库备份必须以bak为前缀，以日期为后缀。 从库必须以-s为后缀。 备库必须以-ss为后缀。 三、表设计规范 单实例表个数必须控制在2000个以内。 单表分表个数必须控制在1024个以内。 必须有主键，推荐使用UNSIGNED整数为主键。 潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住 禁止使用外键，如果要保证完整性，应由应用程式实现。 解读：外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据。 四、列设计规范 根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节。 根据业务区分使用char/varchar。 解读： （1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高 （2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间。 根据业务区分使用datetime/timestamp。 解读：前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime。 必须把字段定义为NOT NULL并设默认值。 解读： （1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化 （2）NULL需要更多的存储空间 （3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑 使用INT UNSIGNED存储IPv4，不要用char(15)。 使用varchar(20)存储手机号，不要使用整数。 解读： （1）牵扯到国家代号，可能出现+/-/()等字符，例如+86 （2）手机号不会用来做数学运算 （3）varchar可以模糊查询，例如like ‘138%’ 使用TINYINT来代替ENUM。 解读：ENUM增加新值要进行DDL操作。 五、索引规范 唯一索引使用uniq_[字段名]来命名。 非唯一索引使用idx_[字段名]来命名。 单张表索引数量建议控制在5个以内。 解读： （1）互联网高并发业务，太多索引会影响写性能。 （2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引。 （3）异常复杂的查询需求，可以选择ES等更为适合的方式存储。 组合索引字段数不建议超过5个。 解读：如果5个字段还不能极大缩小row范围，八成是设计有问题 不建议在频繁更新的字段上建立索引。 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引。 解读：因为JOIN字段类型不一致，而导致全表扫描。 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。 六、SQL规范 禁止使用select *，只获取必要字段。 解读： （1）select *会增加cpu/io/内存/带宽的消耗。 （2）指定字段能有效利用索引覆盖。 （3）指定字段查询，在表结构变更时，能保证对应用程序无影响。 insert必须指定字段，禁止使用insert into T values()。 解读：指定字段插入，在表结构变更时，能保证对应用程序无影响。 隐式类型转换会使索引失效，导致全表扫描。 禁止在where条件列使用函数或者表达式。 解读：导致不能命中索引，全表扫描 禁止负向查询以及%开头的模糊查询。 解读：导致不能命中索引，全表扫描。 禁止大表JOIN和子查询。 同一个字段上的OR必须改写问IN，IN的值必须少于50个。 应用程序必须捕获SQL异常。 解读：方便定位线上问题","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.ithelei.com/tags/MySQL/"}]},{"title":"阿里云标准-Apache Tomcat 安全基线检查","slug":"阿里云标准-Apache Tomcat 安全基线检查","date":"2019-08-27T13:27:24.000Z","updated":"2019-08-27T13:36:34.131Z","comments":true,"path":"2019/08/27/阿里云标准-Apache Tomcat 安全基线检查/","link":"","permalink":"http://www.ithelei.com/2019/08/27/阿里云标准-Apache Tomcat 安全基线检查/","excerpt":"","text":"Tomcat进程运行权限检测 | 访问控制描述 在运行Internet服务时，最好尽可能避免使用root用户运行，降低攻击者拿到服务器控制权限的机会。 加固建议 创建低权限的账号运行Tomcat 操作时建议做好记录或备份 Tomcat目录权限检测 | 访问控制描述 在运行Tomcat服务时，避免使用root用户运行，tomcat目录(catalina.home、 catalina.base目录)所有者应改为非root的运行用户 加固建议 使用chown -R &lt;Tomcat启动用户所属组&gt;:&lt;Tomcat启动用户&gt; &lt;Tomcat目录&gt;修改tomcat目录文件所有者，如chown -R tomcat:tomcat /usr/local/tomcat 操作时建议做好记录或备份 限制服务器平台信息泄漏 | 服务配置描述 限制服务器平台信息泄漏会使攻击者更难确定哪些漏洞会影响服务器平台。 加固建议 1、进入Tomcat安装主目录的lib目录下，比如 cd /usr/local/tomcat7/lib 2、执行：jar xf catalina.jar org/apache/catalina/util/ServerInfo.properties，修改文件ServerInfo.properties中的server.info和server.number的值，如分别改为：Apache/11.0.92、11.0.92.0 3、执行：jar uf catalina.jar org/apache/catalina/util/ServerInfo.properties 4、重启Tomcat服务 操作时建议做好记录或备份 禁止自动部署 | 服务配置描述 配置自动部署，容易被部署恶意或未经测试的应用程序，应将其禁用 加固建议 修改Tomcat 跟目录下的配置文件conf/server.xml，将host节点的autoDeploy属性设置为“false”，如果host的deployOnStartup属性(如没有deployOnStartup配置可以忽略)为“true”，则也将其更改为“false” 操作时建议做好记录或备份 禁止显示异常调试信息 | 服务配置描述 当请求处理期间发生运行时错误时，ApacheTomcat将向请求者显示调试信息。建议不要向请求者提供此类调试信息。 加固建议 在Tomcat根目录下的conf/web.xml文件里面的web-app添加子节点：java.lang.Throwable/error.jsp，在webapps目录下创建error.jsp，定义自定义错误信息 操作时建议做好记录或备份 开启日志记录 | 安全审计描述 Tomcat需要保存输出日志，以便于排除错误和发生安全事件时，进行分析和定位 加固建议 1、修改Tomcat根目录下的conf/server.xml文件。 2、取消Host节点下Valve节点的注释(如没有则添加)。 3、重新启动Tomcat 操作时建议做好记录或备份 禁止Tomcat显示目录文件列表 | 服务配置描述 Tomcat允许显示目录文件列表会引发目录遍历漏洞 加固建议 修改Tomcat 跟目录下的配置文件conf/web.xml，将listings的值设置为false。 listings false 操作时建议做好记录或备份 删除项目无关文件和目录 | 访问控制描述 Tomcat安装提供了示例应用程序、文档和其他可能不用于生产程序及目录，存在极大安全风险，建议移除 加固建议 请删除Tomcat示例程序和目录、管理控制台等，即从Tomcat根目录的webapps目录，移出或删除docs、examples、host-manager、manager目录。 操作时建议做好记录或备份 避免为tomcat配置manager-gui弱口令 | 访问控制描述 tomcat-manger是Tomcat提供的web应用热部署功能，该功能具有较高权限，会直接控制Tomcat应用，应尽量避免使用此功能。如有特殊需求，请务必确保为该功能配置了强口令 加固建议 编辑Tomcat根目录下的配置文件conf/tomcat-user.xml，修改user节点的password属性值为复杂密码, 密码应符合复杂性要求： 1、长度8位以上 2、包含以下四类字符中的三类字符:英文大写字母(A 到 Z)英文小写字母(a 到 z)10 个基本数字(0 到 9)非字母字符(例如 !、$、#、%、@、^、&amp;) 3、避免使用已公开的弱密码，如：abcd.1234 、admin@123等操作时建议做好记录或备份","categories":[{"name":"安全","slug":"安全","permalink":"http://www.ithelei.com/categories/安全/"}],"tags":[{"name":"基线","slug":"基线","permalink":"http://www.ithelei.com/tags/基线/"},{"name":"Apache Tomcat","slug":"Apache-Tomcat","permalink":"http://www.ithelei.com/tags/Apache-Tomcat/"}]},{"title":"CentOS Linux 7安全基线检查","slug":"CentOS Linux 7安全基线检查","date":"2019-08-26T14:25:24.000Z","updated":"2019-08-27T13:20:42.155Z","comments":true,"path":"2019/08/26/CentOS Linux 7安全基线检查/","link":"","permalink":"http://www.ithelei.com/2019/08/26/CentOS Linux 7安全基线检查/","excerpt":"","text":"设置用户权限配置文件的权限 | 文件权限描述 设置用户权限配置文件的权限 加固建议 执行以下5条命令 chown root:root /etc/passwd /etc/shadow /etc/group /etc/gshadow chmod 0644 /etc/group chmod 0644 /etc/passwd chmod 0400 /etc/shadow chmod 0400 /etc/gshadow 操作时建议做好记录或备份 确保SSH LogLevel设置为INFO | 服务配置描述 确保SSH LogLevel设置为INFO,记录登录和注销活动 加固建议 编辑 /etc/ssh/sshd_config 文件以按如下方式设置参数(取消注释): LogLevel INFO 操作时建议做好记录或备份 设置SSH空闲超时退出时间 | 服务配置描述 设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险 加固建议 编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0。 ClientAliveInterval 900 ClientAliveCountMax 0 操作时建议做好记录或备份 SSHD强制使用V2安全协议 | 服务配置描述 SSHD强制使用V2安全协议 加固建议 编辑 /etc/ssh/sshd_config 文件以按如下方式设置参数： Protocol 2 操作时建议做好记录或备份 确保SSH MaxAuthTries设置为3到6之间 | 服务配置描述 设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险。 加固建议 在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4： MaxAuthTries 4 操作时建议做好记录或备份 设置密码修改最小间隔时间 | 身份鉴别描述 设置密码修改最小间隔时间，限制密码更改过于频繁 加固建议 在 /etc/login.defs 中将 PASS_MIN_DAYS 参数设置为7-14之间,建议为7： PASS_MIN_DAYS 7 需同时执行命令为root用户设置： chage –mindays 7 root 操作时建议做好记录或备份 设置密码失效时间 | 身份鉴别描述 设置密码失效时间，强制定期修改密码，减少密码被泄漏和猜测风险，使用非密码登陆方式(如密钥对)请忽略此项。 加固建议 使用非密码登陆方式如密钥对，请忽略此项。在 /etc/login.defs 中将 PASS_MAX_DAYS 参数设置为 60-180之间，如 PASS_MAX_DAYS 90。需同时执行命令设置root密码失效时间： chage –maxdays 90 root。 操作时建议做好记录或备份 禁止SSH空密码用户登录 | 服务配置描述 禁止SSH空密码用户登录 加固建议 在/etc/ssh/sshd_config中取消PermitEmptyPasswords no注释符号# 操作时建议做好记录或备份 确保root是唯一的UID为0的帐户 | 身份鉴别描述 除root以外其他UID为0的用户都应该删除，或者为其分配新的UID 加固建议 除root以外其他UID为0的用户(查看命令cat /etc/passwd | awk -F: ‘($3 == 0) { print $1 }’|grep -v ‘^root$’ )都应该删除，或者为其分配新的UID 操作时建议做好记录或备份","categories":[{"name":"安全","slug":"安全","permalink":"http://www.ithelei.com/categories/安全/"}],"tags":[{"name":"CentOS Linux 7","slug":"CentOS-Linux-7","permalink":"http://www.ithelei.com/tags/CentOS-Linux-7/"},{"name":"基线","slug":"基线","permalink":"http://www.ithelei.com/tags/基线/"}]}]}